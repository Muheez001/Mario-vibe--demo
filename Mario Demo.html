<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mario Platformer Game</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(to bottom, #87CEEB, #98FB98);
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        #gameContainer {
            border: 3px solid #8B4513;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        
        canvas {
            display: block;
            background: linear-gradient(to bottom, #87CEEB 0%, #87CEEB 60%, #90EE90 60%, #228B22 100%);
        }
        
        #controls {
            margin-top: 20px;
            text-align: center;
            background: rgba(255,255,255,0.9);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
        
        #score {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 20px;
            color: #333;
        }
        
        .game-over, .game-win {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            font-size: 24px;
            z-index: 1000;
        }
        
        button {
            background: #FF6B35;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            margin-top: 15px;
        }
        
        button:hover {
            background: #E55A2B;
        }
    </style>
</head>
<body>
    <div id="score">Score: 0</div>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="400"></canvas>
    </div>
    
    <div id="controls">
        <p><strong>Controls:</strong></p>
        <p>Move: WASD or Arrow Keys | Jump: Space Bar</p>
        <p>Avoid enemies and reach the flag to win!</p>
        <p><em>Click anywhere or press any key to start background music</em></p>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');

        // Background music
        let backgroundMusic;
        let musicStarted = false;

        function initAudio() {
            if (!musicStarted) {
                // Create audio context and background music
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Simple copyright-free background music using Web Audio API
                function createBackgroundMusic() {
                    const oscillator1 = audioContext.createOscillator();
                    const oscillator2 = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator1.type = 'square';
                    oscillator2.type = 'square';
                    
                    gainNode.gain.value = 0.1; // Low volume
                    
                    oscillator1.connect(gainNode);
                    oscillator2.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    // Simple melody pattern
                    const notes = [262, 294, 330, 349, 392, 440, 494, 523]; // C major scale
                    let noteIndex = 0;
                    
                    function playNextNote() {
                        if (gameRunning) {
                            oscillator1.frequency.value = notes[noteIndex % notes.length];
                            oscillator2.frequency.value = notes[(noteIndex + 2) % notes.length];
                            noteIndex++;
                            setTimeout(playNextNote, 500);
                        }
                    }
                    
                    oscillator1.start();
                    oscillator2.start();
                    playNextNote();
                }
                
                createBackgroundMusic();
                musicStarted = true;
            }
        }

        // Game state
        let score = 0;
        let gameRunning = true;
        let camera = { x: 0, y: 0 };

        // Player object
        const player = {
            x: 50,
            y: 300,
            width: 30,
            height: 30,
            velocityX: 0,
            velocityY: 0,
            speed: 5,
            jumpPower: 15,
            onGround: false,
            color: '#FF0000'
        };

        // Input handling
        const keys = {};
        
        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            if (e.key === ' ') {
                e.preventDefault();
            }
            
            // Start music on first input
            if (!musicStarted) {
                initAudio();
            }
        });
        
        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        // Click to start music
        canvas.addEventListener('click', () => {
            if (!musicStarted) {
                initAudio();
            }
        });

        // Platforms
        const platforms = [
            // Ground platforms
            { x: 0, y: 370, width: 200, height: 30, color: '#8B4513' },
            { x: 250, y: 370, width: 150, height: 30, color: '#8B4513' },
            { x: 450, y: 370, width: 200, height: 30, color: '#8B4513' },
            { x: 700, y: 370, width: 150, height: 30, color: '#8B4513' },
            { x: 900, y: 370, width: 200, height: 30, color: '#8B4513' },
            { x: 1150, y: 370, width: 150, height: 30, color: '#8B4513' },
            { x: 1350, y: 370, width: 200, height: 30, color: '#8B4513' },
            
            // Floating platforms
            { x: 300, y: 280, width: 100, height: 20, color: '#228B22' },
            { x: 500, y: 250, width: 80, height: 20, color: '#228B22' },
            { x: 750, y: 280, width: 120, height: 20, color: '#228B22' },
            { x: 950, y: 220, width: 100, height: 20, color: '#228B22' },
            { x: 1200, y: 280, width: 80, height: 20, color: '#228B22' },
            { x: 1400, y: 250, width: 100, height: 20, color: '#228B22' }
        ];

        // Enemies
        const enemies = [
            { x: 280, y: 340, width: 25, height: 25, velocityX: 2, color: '#8B0000', patrolStart: 250, patrolEnd: 400 },
            { x: 480, y: 340, width: 25, height: 25, velocityX: -1.5, color: '#8B0000', patrolStart: 450, patrolEnd: 600 },
            { x: 780, y: 340, width: 25, height: 25, velocityX: 2.5, color: '#8B0000', patrolStart: 700, patrolEnd: 850 },
            { x: 980, y: 340, width: 25, height: 25, velocityX: -2, color: '#8B0000', patrolStart: 900, patrolEnd: 1100 },
            { x: 1180, y: 340, width: 25, height: 25, velocityX: 1.8, color: '#8B0000', patrolStart: 1150, patrolEnd: 1300 }
        ];

        // Goal flag
        const goal = {
            x: 1500,
            y: 250,
            width: 20,
            height: 120,
            color: '#FFD700'
        };

        // Collectibles
        const coins = [
            { x: 330, y: 250, width: 15, height: 15, collected: false },
            { x: 520, y: 220, width: 15, height: 15, collected: false },
            { x: 780, y: 250, width: 15, height: 15, collected: false },
            { x: 980, y: 190, width: 15, height: 15, collected: false },
            { x: 1220, y: 250, width: 15, height: 15, collected: false }
        ];

        // Question blocks
        const questionBlocks = [
            { x: 200, y: 320, width: 30, height: 30, active: true, bounceOffset: 0 },
            { x: 350, y: 240, width: 30, height: 30, active: true, bounceOffset: 0 },
            { x: 550, y: 200, width: 30, height: 30, active: true, bounceOffset: 0 },
            { x: 800, y: 240, width: 30, height: 30, active: true, bounceOffset: 0 },
            { x: 1000, y: 180, width: 30, height: 30, active: true, bounceOffset: 0 },
            { x: 1250, y: 240, width: 30, height: 30, active: true, bounceOffset: 0 }
        ];

        // Spawned coins from ? blocks
        const spawnedCoins = [];

        // Sprite drawing functions
        function drawMario(x, y) {
            // Mario sprite using rectangles to create a pixelated look
            const pixelSize = 2;
            
            // Red hat
            ctx.fillStyle = '#DC143C';
            ctx.fillRect(x + 4*pixelSize, y + 2*pixelSize, 8*pixelSize, 4*pixelSize);
            
            // Brown hair
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(x + 2*pixelSize, y + 6*pixelSize, 4*pixelSize, 2*pixelSize);
            ctx.fillRect(x + 10*pixelSize, y + 6*pixelSize, 4*pixelSize, 2*pixelSize);
            
            // Peach face
            ctx.fillStyle = '#FDBCB4';
            ctx.fillRect(x + 4*pixelSize, y + 6*pixelSize, 6*pixelSize, 6*pixelSize);
            
            // Black eyes
            ctx.fillStyle = '#000000';
            ctx.fillRect(x + 5*pixelSize, y + 8*pixelSize, pixelSize, pixelSize);
            ctx.fillRect(x + 8*pixelSize, y + 8*pixelSize, pixelSize, pixelSize);
            
            // Red nose
            ctx.fillStyle = '#DC143C';
            ctx.fillRect(x + 7*pixelSize, y + 9*pixelSize, pixelSize, pixelSize);
            
            // Brown mustache
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(x + 5*pixelSize, y + 10*pixelSize, 4*pixelSize, pixelSize);
            
            // Red shirt
            ctx.fillStyle = '#DC143C';
            ctx.fillRect(x + 3*pixelSize, y + 12*pixelSize, 8*pixelSize, 6*pixelSize);
            
            // Blue overalls
            ctx.fillStyle = '#0000FF';
            ctx.fillRect(x + 4*pixelSize, y + 18*pixelSize, 6*pixelSize, 6*pixelSize);
            
            // Yellow buttons
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(x + 5*pixelSize, y + 19*pixelSize, pixelSize, pixelSize);
            ctx.fillRect(x + 8*pixelSize, y + 19*pixelSize, pixelSize, pixelSize);
            
            // Brown shoes
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(x + 2*pixelSize, y + 24*pixelSize, 4*pixelSize, 4*pixelSize);
            ctx.fillRect(x + 8*pixelSize, y + 24*pixelSize, 4*pixelSize, 4*pixelSize);
        }

        function drawGoomba(x, y) {
            // Goomba sprite - brown mushroom enemy
            const pixelSize = 2;
            
            // Brown body
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(x + 2*pixelSize, y + 6*pixelSize, 10*pixelSize, 8*pixelSize);
            
            // Darker brown shading
            ctx.fillStyle = '#654321';
            ctx.fillRect(x + 3*pixelSize, y + 7*pixelSize, 8*pixelSize, 6*pixelSize);
            
            // Black eyes
            ctx.fillStyle = '#000000';
            ctx.fillRect(x + 4*pixelSize, y + 8*pixelSize, 2*pixelSize, 2*pixelSize);
            ctx.fillRect(x + 8*pixelSize, y + 8*pixelSize, 2*pixelSize, 2*pixelSize);
            
            // White eye highlights
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(x + 4*pixelSize, y + 8*pixelSize, pixelSize, pixelSize);
            ctx.fillRect(x + 8*pixelSize, y + 8*pixelSize, pixelSize, pixelSize);
            
            // Angry eyebrows
            ctx.fillStyle = '#000000';
            ctx.fillRect(x + 3*pixelSize, y + 7*pixelSize, 3*pixelSize, pixelSize);
            ctx.fillRect(x + 8*pixelSize, y + 7*pixelSize, 3*pixelSize, pixelSize);
            
            // Small feet
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(x + 1*pixelSize, y + 13*pixelSize, 3*pixelSize, 2*pixelSize);
            ctx.fillRect(x + 10*pixelSize, y + 13*pixelSize, 3*pixelSize, 2*pixelSize);
        }

        // Physics constants
        const gravity = 0.8;
        const friction = 0.8;

        function updatePlayer() {
            if (!gameRunning) return;

            // Handle input
            player.velocityX = 0;
            
            if (keys['a'] || keys['arrowleft']) {
                player.velocityX = -player.speed;
            }
            if (keys['d'] || keys['arrowright']) {
                player.velocityX = player.speed;
            }
            if ((keys[' '] || keys['w'] || keys['arrowup']) && player.onGround) {
                player.velocityY = -player.jumpPower;
                player.onGround = false;
            }

            // Apply gravity
            player.velocityY += gravity;

            // Update position
            player.x += player.velocityX;
            player.y += player.velocityY;

            // Reset onGround flag
            player.onGround = false;

            // Platform collision
            platforms.forEach(platform => {
                if (player.x < platform.x + platform.width &&
                    player.x + player.width > platform.x &&
                    player.y < platform.y + platform.height &&
                    player.y + player.height > platform.y) {
                    
                    // Landing on top
                    if (player.velocityY > 0 && player.y < platform.y) {
                        player.y = platform.y - player.height;
                        player.velocityY = 0;
                        player.onGround = true;
                    }
                    // Hitting from below
                    else if (player.velocityY < 0 && player.y > platform.y) {
                        player.y = platform.y + platform.height;
                        player.velocityY = 0;
                    }
                    // Side collisions
                    else if (player.velocityX > 0) {
                        player.x = platform.x - player.width;
                    } else if (player.velocityX < 0) {
                        player.x = platform.x + platform.width;
                    }
                }
            });

            // Question block collision
            questionBlocks.forEach(block => {
                if (block.active &&
                    player.x < block.x + block.width &&
                    player.x + player.width > block.x &&
                    player.y < block.y + block.height &&
                    player.y + player.height > block.y) {
                    
                    // Hit from below (player's head hitting the block)
                    if (player.velocityY < 0 && player.y > block.y) {
                        player.y = block.y + block.height;
                        player.velocityY = 0;
                        
                        // Activate the block
                        hitQuestionBlock(block);
                    }
                    // Landing on top
                    else if (player.velocityY > 0 && player.y < block.y) {
                        player.y = block.y - player.height;
                        player.velocityY = 0;
                        player.onGround = true;
                    }
                    // Side collisions
                    else if (player.velocityX > 0) {
                        player.x = block.x - player.width;
                    } else if (player.velocityX < 0) {
                        player.x = block.x + block.width;
                    }
                }
            });

            // Boundary checking
            if (player.y > canvas.height) {
                gameOver();
            }
            if (player.x < 0) player.x = 0;

            // Update camera to follow player
            camera.x = player.x - canvas.width / 2;
            if (camera.x < 0) camera.x = 0;
            if (camera.x > 1600 - canvas.width) camera.x = 1600 - canvas.width;
        }

        function updateEnemies() {
            enemies.forEach(enemy => {
                enemy.x += enemy.velocityX;
                
                // Patrol behavior
                if (enemy.x <= enemy.patrolStart || enemy.x >= enemy.patrolEnd) {
                    enemy.velocityX *= -1;
                }
                
                // Enemy collision with player
                if (player.x < enemy.x + enemy.width &&
                    player.x + player.width > enemy.x &&
                    player.y < enemy.y + enemy.height &&
                    player.y + player.height > enemy.y) {
                    
                    // Check if player is jumping on enemy
                    if (player.velocityY > 0 && player.y < enemy.y - 10) {
                        // Player defeats enemy
                        enemy.x = -1000; // Move enemy off screen
                        player.velocityY = -8; // Small bounce
                        score += 100;
                    } else {
                        gameOver();
                    }
                }
            });
        }

        function updateCoins() {
            coins.forEach(coin => {
                if (!coin.collected &&
                    player.x < coin.x + coin.width &&
                    player.x + player.width > coin.x &&
                    player.y < coin.y + coin.height &&
                    player.y + player.height > coin.y) {
                    
                    coin.collected = true;
                    score += 50;
                }
            });

            // Update spawned coins from ? blocks
            spawnedCoins.forEach((coin, index) => {
                coin.timer--;
                coin.y -= coin.velocityY; // Move upward
                coin.velocityY -= 0.5; // Gravity effect
                
                // Check collision with player
                if (!coin.collected &&
                    player.x < coin.x + coin.width &&
                    player.x + player.width > coin.x &&
                    player.y < coin.y + coin.height &&
                    player.y + player.height > coin.y) {
                    
                    coin.collected = true;
                    score += 100;
                }
                
                // Remove coin after timer expires or if collected
                if (coin.timer <= 0 || coin.collected) {
                    spawnedCoins.splice(index, 1);
                }
            });
        }

        function hitQuestionBlock(block) {
            if (!block.active) return;
            
            block.active = false;
            block.bounceOffset = -8; // Block bounce animation
            
            // Spawn coin above the block
            const newCoin = {
                x: block.x + block.width/2 - 7.5,
                y: block.y - 20,
                width: 15,
                height: 15,
                timer: 180, // 3 seconds at 60fps
                velocityY: 8, // Initial upward velocity
                collected: false
            };
            
            spawnedCoins.push(newCoin);
        }

        function updateQuestionBlocks() {
            questionBlocks.forEach(block => {
                // Animate block bounce
                if (block.bounceOffset < 0) {
                    block.bounceOffset += 0.5;
                    if (block.bounceOffset > 0) block.bounceOffset = 0;
                }
            });
        }

        function checkGoal() {
            if (player.x < goal.x + goal.width &&
                player.x + player.width > goal.x &&
                player.y < goal.y + goal.height &&
                player.y + player.height > goal.y) {
                gameWin();
            }
        }

        function render() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Save context for camera transform
            ctx.save();
            ctx.translate(-camera.x, -camera.y);

            // Draw platforms
            platforms.forEach(platform => {
                ctx.fillStyle = platform.color;
                ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                
                // Add some texture
                ctx.fillStyle = '#654321';
                ctx.fillRect(platform.x, platform.y, platform.width, 5);
            });

            // Draw enemies
            enemies.forEach(enemy => {
                if (enemy.x > -1000) { // Only draw if not defeated
                    drawGoomba(enemy.x, enemy.y);
                }
            });

            // Draw coins
            coins.forEach(coin => {
                if (!coin.collected) {
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(coin.x + coin.width/2, coin.y + coin.height/2, coin.width/2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#FFA500';
                    ctx.beginPath();
                    ctx.arc(coin.x + coin.width/2, coin.y + coin.height/2, coin.width/4, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // Draw question blocks
            questionBlocks.forEach(block => {
                ctx.fillStyle = block.active ? '#DAA520' : '#8B4513';
                ctx.fillRect(block.x, block.y + block.bounceOffset, block.width, block.height);
                
                if (block.active) {
                    // Draw ? symbol
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = '20px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('?', block.x + block.width/2, block.y + block.bounceOffset + block.height/2 + 7);
                    
                    // Draw block border
                    ctx.strokeStyle = '#B8860B';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(block.x, block.y + block.bounceOffset, block.width, block.height);
                } else {
                    // Empty block appearance
                    ctx.strokeStyle = '#654321';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(block.x, block.y + block.bounceOffset, block.width, block.height);
                }
            });

            // Draw spawned coins
            spawnedCoins.forEach(coin => {
                if (!coin.collected) {
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(coin.x + coin.width/2, coin.y + coin.height/2, coin.width/2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#FFA500';
                    ctx.beginPath();
                    ctx.arc(coin.x + coin.width/2, coin.y + coin.height/2, coin.width/4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Add sparkle effect
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(coin.x + coin.width/2 - 1, coin.y + 2, 2, 4);
                    ctx.fillRect(coin.x + 2, coin.y + coin.height/2 - 1, 4, 2);
                }
            });

            // Draw goal flag
            ctx.fillStyle = goal.color;
            ctx.fillRect(goal.x, goal.y, goal.width, goal.height);
            ctx.fillStyle = '#FF0000';
            ctx.fillRect(goal.x, goal.y, goal.width - 5, 40);
            
            // Flag pole
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(goal.x + 8, goal.y, 4, goal.height + 20);

            // Draw player
            drawMario(player.x, player.y);

            // Draw clouds in background
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            for (let i = 0; i < 5; i++) {
                let cloudX = 200 + i * 300;
                ctx.beginPath();
                ctx.arc(cloudX, 80, 25, 0, Math.PI * 2);
                ctx.arc(cloudX + 25, 80, 35, 0, Math.PI * 2);
                ctx.arc(cloudX + 50, 80, 25, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
        }

        function gameOver() {
            gameRunning = false;
            const gameOverDiv = document.createElement('div');
            gameOverDiv.className = 'game-over';
            gameOverDiv.innerHTML = `
                <h2>Game Over!</h2>
                <p>Final Score: ${score}</p>
                <button onclick="restartGame()">Try Again</button>
            `;
            document.body.appendChild(gameOverDiv);
        }

        function gameWin() {
            gameRunning = false;
            score += 500; // Bonus for winning
            const gameWinDiv = document.createElement('div');
            gameWinDiv.className = 'game-win';
            gameWinDiv.innerHTML = `
                <h2>🎉 You Won! 🎉</h2>
                <p>Final Score: ${score}</p>
                <p>Congratulations, Mario!</p>
                <button onclick="restartGame()">Play Again</button>
            `;
            document.body.appendChild(gameWinDiv);
        }

        function restartGame() {
            // Remove game over/win screen
            const overlays = document.querySelectorAll('.game-over, .game-win');
            overlays.forEach(overlay => overlay.remove());
            
            // Reset game state
            score = 0;
            gameRunning = true;
            
            // Reset player
            player.x = 50;
            player.y = 300;
            player.velocityX = 0;
            player.velocityY = 0;
            player.onGround = false;
            
            // Reset camera
            camera.x = 0;
            camera.y = 0;
            
            // Reset enemies
            enemies[0].x = 280;
            enemies[1].x = 480;
            enemies[2].x = 780;
            enemies[3].x = 980;
            enemies[4].x = 1180;
            
            // Reset coins
            coins.forEach(coin => coin.collected = false);
            
            // Reset question blocks
            questionBlocks.forEach(block => {
                block.active = true;
                block.bounceOffset = 0;
            });
            
            // Clear spawned coins
            spawnedCoins.length = 0;
        }

        function gameLoop() {
            updatePlayer();
            updateEnemies();
            updateCoins();
            updateQuestionBlocks();
            checkGoal();
            render();
            
            // Update score display
            scoreElement.textContent = `Score: ${score}`;
            
            requestAnimationFrame(gameLoop);
        }

        // Start the game
        gameLoop();
    </script>
</body>
</html>