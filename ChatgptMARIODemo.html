<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Mini Mario-like</title>
  <style>
    html, body { height: 100%; margin: 0; background:#0f1220; color:#fff; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
    .wrap { display:flex; flex-direction:column; align-items:center; gap:8px; padding:10px; }
    canvas { background: linear-gradient(#8fd3ff, #bfe9ff 40%, #9ad18b 40%); border-radius:16px; box-shadow: 0 8px 24px rgba(0,0,0,.35); max-width: 100%; }
    .hud { display:flex; gap:14px; flex-wrap:wrap; align-items:center; justify-content:center; }
    .pill { background:#1b1e34; padding:6px 10px; border-radius:999px; font-size:14px; opacity:.9 }
    kbd { background:#2a2f55; padding:2px 6px; border-radius:6px; border:1px solid #39407a; }
    .msg { min-height: 22px; font-weight:600; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <div class="pill">Move: <kbd>A</kbd> <kbd>S</kbd> <kbd>D</kbd> or <kbd>◀</kbd> <kbd>▼</kbd> <kbd>▶</kbd></div>
      <div class="pill">Jump: <kbd>Space</kbd> (also <kbd>W</kbd> or <kbd>▲</kbd>)</div>
      <div class="pill">Goal: touch the flag at the far right</div>
      <div class="pill">Tip: you can stomp enemies</div>
    </div>
    <div class="msg" id="msg"></div>
    <canvas id="game" width="960" height="540" aria-label="Mario-like 2D game"></canvas>
  </div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const msg = document.getElementById('msg');

  const TILE = 48; // tile size in pixels
  const GRAV = 0.9; // gravity
  const MOVE = 0.7; // acceleration
  const AIR_MOVE = 0.4;
  const MAXSPEED = 6.0;
  const JUMP = 16;

  // Simple tile legend
  // X block, G goal, C coin, E enemy spawn, B bounce block
  // S player spawn
  const MAP = [
    "..............................................................................................",
    "..............................................................................................",
    "..............................................................................................",
    "............................C.................C...............................................",
    "....................C.........................................................C..............",
    "..............................................................................................",
    "..........C.........................E.........................................................",
    "XXXXXXXXXXXXXXXXXXXXXXXXXXXXX....XXXXXXXXXXXXXXXXXXXXXXXXXXXX......XXXXXXXXXXXXXX..............",
    "............................X.........................C.....X..................X..............",
    "..S.........................X..............E................X..............E...X...........G..",
    "XXXXXXXXXXXXXXXXXX....XXXXXXX....XXXXXXXXXXXXXX....XXXXXXXXXXX....XXXXXXXXXXXXXXX..XXXXXXXXXXXX",
    "..............................................................................................",
  ];

  const world = {
    width: MAP[0].length * TILE,
    height: MAP.length * TILE,
  };

  // Camera
  const camera = { x: 0, y: 0, w: canvas.width, h: canvas.height };

  // Input
  const keys = new Set();
  window.addEventListener('keydown', e => {
    if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", " ", "Space", "A", "S", "D", "W"].includes(e.key)) {
      e.preventDefault();
    }
    keys.add(e.key);
  });
  window.addEventListener('keyup', e => keys.delete(e.key));

  // Utility
  function rectsOverlap(a, b) {
    return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
  }

  function tileAt(px, py) {
    if (px < 0 || py < 0) return 'X';
    const tx = Math.floor(px / TILE);
    const ty = Math.floor(py / TILE);
    if (ty < 0 || ty >= MAP.length || tx < 0 || tx >= MAP[0].length) return 'X';
    return MAP[ty][tx];
  }

  function solidAtRect(r) {
    // Check four corners
    const corners = [
      [r.x, r.y],
      [r.x + r.w - 1, r.y],
      [r.x, r.y + r.h - 1],
      [r.x + r.w - 1, r.y + r.h - 1]
    ];
    for (const [cx, cy] of corners) {
      if (tileAt(cx, cy) === 'X') return true;
    }
    return false;
  }

  // Entities
  const player = { x: 0, y: 0, w: 32, h: 44, vx: 0, vy: 0, onGround: false, coins: 0, alive: true, win: false };
  const enemies = [];
  const coins = [];
  let goal = { x: 0, y: 0, w: TILE, h: TILE };

  function resetFromMap() {
    enemies.length = 0;
    coins.length = 0;
    player.vx = 0; player.vy = 0; player.onGround = false; player.alive = true; player.win = false; player.coins = 0;

    for (let ty = 0; ty < MAP.length; ty++) {
      for (let tx = 0; tx < MAP[0].length; tx++) {
        const ch = MAP[ty][tx];
        const px = tx * TILE, py = ty * TILE;
        if (ch === 'S') { player.x = px; player.y = py - 10; }
        if (ch === 'E') { enemies.push({ x: px, y: py - TILE, w: 36, h: 36, vx: 1.2, vy: 0, dir: 1, minX: px - TILE * 2, maxX: px + TILE * 2, alive: true }); }
        if (ch === 'C') { coins.push({ x: px + 12, y: py + 12, w: 24, h: 24, taken: false, t: Math.random()*6.28 }); }
        if (ch === 'G') { goal = { x: px, y: py - TILE, w: TILE, h: TILE * 2 } }
      }
    }
    camera.x = Math.max(0, Math.min(player.x - canvas.width * 0.35, world.width - canvas.width));
    camera.y = 0;
    msg.textContent = '';
  }

  resetFromMap();

  // Physics and game loop
  function update() {
    if (!player.alive || player.win) return;

    // Input
    const left = keys.has('a') || keys.has('A') || keys.has('ArrowLeft');
    const right = keys.has('d') || keys.has('D') || keys.has('ArrowRight');
    const up = keys.has(' ') || keys.has('Space') || keys.has('w') || keys.has('W') || keys.has('ArrowUp');

    const accel = player.onGround ? MOVE : AIR_MOVE;
    if (left && !right) player.vx -= accel;
    if (right && !left) player.vx += accel;
    if (!(left ^ right)) player.vx *= player.onGround ? 0.8 : 0.99; // friction and air drag
    player.vx = Math.max(-MAXSPEED, Math.min(MAXSPEED, player.vx));

    // Jump
    if (up && player.onGround) {
      player.vy = -JUMP;
      player.onGround = false;
    }

    // Apply gravity
    player.vy += GRAV;
    if (player.vy > 18) player.vy = 18;

    // Horizontal move and collision
    player.x += player.vx;
    if (solidAtRect(player)) {
      const dir = Math.sign(player.vx);
      while (solidAtRect(player)) { player.x -= dir * 1; }
      player.vx = 0;
    }

    // Vertical move and collision
    player.y += player.vy;
    if (solidAtRect(player)) {
      const dir = Math.sign(player.vy);
      while (solidAtRect(player)) { player.y -= dir * 1; }
      if (dir > 0) player.onGround = true;
      player.vy = 0;
    } else {
      player.onGround = false;
    }

    // Collect coins
    for (const c of coins) {
      if (!c.taken && rectsOverlap(player, c)) { c.taken = true; player.coins++; }
      c.t += 0.08;
    }

    // Enemies
    for (const en of enemies) {
      if (!en.alive) continue;
      en.vy += GRAV * 0.9;
      en.x += en.vx * en.dir;
      if (en.x < en.minX || en.x + en.w > en.maxX) en.dir *= -1;

      const hbox = { x: en.x, y: en.y, w: en.w, h: en.h };
      if (solidAtRect(hbox)) {
        en.x -= en.vx * en.dir;
        en.dir *= -1;
      }
      en.y += en.vy;
      const vbox = { x: en.x, y: en.y, w: en.w, h: en.h };
      if (solidAtRect(vbox)) {
        const dirY = Math.sign(en.vy);
        while (solidAtRect(vbox)) { en.y -= dirY * 1; vbox.y = en.y; }
        en.vy = 0;
      }

      if (rectsOverlap(player, en)) {
        const isStomp = (player.vy > 0) && (player.y + player.h - en.y < 16);
        if (isStomp) {
          en.alive = false; player.vy = -JUMP * 0.7;
        } else {
          player.alive = false; msg.textContent = `Ouch, try again. Press R to restart.`;
        }
      }
    }

    if (rectsOverlap(player, goal)) {
      player.win = true;
      msg.textContent = `You win, coins: ${player.coins}. Press R to play again.`;
    }

    if (player.y > world.height + 200) {
      player.alive = false; msg.textContent = `You fell, press R to restart.`;
    }

    const target = player.x - canvas.width * 0.35;
    camera.x += (Math.max(0, Math.min(target, world.width - canvas.width)) - camera.x) * 0.15;
  }

  window.addEventListener('keydown', e => {
    if ((e.key === 'r' || e.key === 'R') && (!player.alive || player.win)) {
      resetFromMap();
    }
  });

  function drawTile(tx, ty, ch) {
    const x = tx * TILE - camera.x;
    const y = ty * TILE - camera.y;
    if (ch === 'X') {
      ctx.fillStyle = '#6c8b4f';
      ctx.fillRect(x, y, TILE, TILE);
      ctx.fillStyle = '#4f6a38';
      ctx.fillRect(x, y + TILE - 12, TILE, 12);
    } else if (ch === 'G') {
      const poleX = x + TILE/2 - 3;
      ctx.fillStyle = '#c9c9c9';
      ctx.fillRect(poleX, y - TILE, 6, TILE * 2);
      ctx.fillStyle = '#ff3b30';
      ctx.beginPath();
      ctx.moveTo(poleX + 6, y - TILE + 8);
      ctx.lineTo(poleX + 6 + 28, y - TILE + 16);
      ctx.lineTo(poleX + 6, y - TILE + 24);
      ctx.closePath();
      ctx.fill();
    }
  }

  function render() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const hillH = 120;
    for (let i = -1; i < 8; i++) {
      const x = i * 200 - (camera.x * 0.3 % 200);
      ctx.fillStyle = '#7bc96f';
      ctx.beginPath();
      ctx.arc(x + 100, canvas.height - 80, hillH, Math.PI, 0);
      ctx.fill();
    }

    const x0 = Math.floor(camera.x / TILE) - 1;
    const x1 = Math.floor((camera.x + canvas.width) / TILE) + 1;
    for (let ty = 0; ty < MAP.length; ty++) {
      for (let tx = Math.max(0, x0); tx <= Math.min(MAP[0].length - 1, x1); tx++) {
        const ch = MAP[ty][tx];
        if (ch === 'X' || ch === 'G') drawTile(tx, ty, ch);
      }
    }

    for (const c of coins) {
      if (c.taken) continue;
      const x = c.x - camera.x + Math.sin(c.t) * 2;
      const y = c.y - camera.y - Math.sin(c.t*2) * 4;
      ctx.fillStyle = '#ffd54a';
      ctx.beginPath();
      ctx.arc(x + c.w/2, y + c.h/2, 10, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#fff7c2';
      ctx.fillRect(x + c.w/2 - 2, y + 4, 4, 10);
    }

    for (const en of enemies) {
      if (!en.alive) continue;
      const x = en.x - camera.x, y = en.y - camera.y;
      ctx.fillStyle = '#9b4dca';
      ctx.fillRect(x, y, en.w, en.h);
      ctx.fillStyle = '#fff';
      ctx.fillRect(x + 6, y + 8, 8, 8);
      ctx.fillRect(x + en.w - 14, y + 8, 8, 8);
      ctx.fillStyle = '#111';
      ctx.fillRect(x + 9, y + 11, 3, 3);
      ctx.fillRect(x + en.w - 11, y + 11, 3, 3);
    }

    const px = player.x - camera.x, py = player.y - camera.y;
    ctx.fillStyle = '#ff6b6b';
    ctx.fillRect(px, py, player.w, player.h);
    ctx.fillStyle = '#e63b3b';
    ctx.fillRect(px - 2, py - 8, player.w + 4, 10);

    ctx.fillStyle = '#0a0a0a';
    ctx.globalAlpha = 0.2;
    ctx.fillRect(12, 12, 220, 64);
    ctx.globalAlpha = 1;
    ctx.fillStyle = '#ffffff';
    ctx.font = '16px ui-sans-serif, system-ui';
    ctx.fillText(`Coins: ${player.coins}`, 24, 36);

    requestAnimationFrame(loop);
  }

  function loop() {
    update();
    render();
  }

  function fit() {
    const maxW = Math.min(window.innerWidth - 24, 1200);
    const scale = maxW / canvas.width;
    canvas.style.transformOrigin = 'top left';
    canvas.style.transform = `scale(${Math.max(0.5, Math.min(1.5, scale))})`;
  }
  window.addEventListener('resize', fit);
  fit();

  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
